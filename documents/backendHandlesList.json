{
  "key": "backendHandlesList",
  "value": [
    {
      "fileName": "register.ts",
      "handleProcedure": "1. クライアントから送信されたユーザー情報を受け取る 2. ユーザー名とメールアドレスの一意性を確認 3. パスワードをハッシュ化 4. usersテーブルに新規ユーザーを登録 5. 登録成功時はユーザー情報を返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-002",
      "handleName": "ユーザー登録",
      "description": "新規ユーザーの登録処理",
      "id": "BAC-001",
      "category": "認証",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Register from '@/app/register/page';\nimport { useRouter } from 'next/navigation';\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('Register コンポーネント', () => {\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockReturnValue({\n      push: jest.fn(),\n    });\n  });\n\n  test('全ての入力フィールドとボタンが表示されること', () => {\n    render(<Register />);\n    \n    expect(screen.getByLabelText('ユーザー名')).toBeInTheDocument();\n    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument();\n    expect(screen.getByLabelText('パスワード')).toBeInTheDocument();\n    expect(screen.getByLabelText('パスワード確認')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: '登録' })).toBeInTheDocument();\n    expect(screen.getByText('ログイン画面へ')).toBeInTheDocument();\n  });\n\n  test('バリデーションエラーが表示されること', async () => {\n    render(<Register />);\n    \n    fireEvent.click(screen.getByRole('button', { name: '登録' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('ユーザー名を入力してください')).toBeInTheDocument();\n      expect(screen.getByText('メールアドレスを入力してください')).toBeInTheDocument();\n      expect(screen.getByText('パスワードを入力してください')).toBeInTheDocument();\n      expect(screen.getByText('パスワード確認を入力してください')).toBeInTheDocument();\n    });\n  });\n\n  test('パスワードと確認用パスワードが一致しない場合エラーが表示されること', async () => {\n    render(<Register />);\n    \n    fireEvent.change(screen.getByLabelText('パスワード'), { target: { value: 'password123' } });\n    fireEvent.change(screen.getByLabelText('パスワード確認'), { target: { value: 'password456' } });\n    fireEvent.click(screen.getByRole('button', { name: '登録' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('パスワードが一致しません')).toBeInTheDocument();\n    });\n  });\n\n  test('正常に登録できること', async () => {\n    const mockPush = jest.fn();\n    (useRouter as jest.Mock).mockReturnValue({\n      push: mockPush,\n    });\n\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({ message: '登録成功' }),\n    });\n\n    render(<Register />);\n    \n    fireEvent.change(screen.getByLabelText('ユーザー名'), { target: { value: 'testuser' } });\n    fireEvent.change(screen.getByLabelText('メールアドレス'), { target: { value: 'test@example.com' } });\n    fireEvent.change(screen.getByLabelText('パスワード'), { target: { value: 'password123' } });\n    fireEvent.change(screen.getByLabelText('パスワード確認'), { target: { value: 'password123' } });\n    fireEvent.click(screen.getByRole('button', { name: '登録' }));\n\n    await waitFor(() => {\n      expect(mockPush).toHaveBeenCalledWith('/');\n    });\n  });\n\n  test('登録に失敗した場合エラーメッセージが表示されること', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: false,\n      json: async () => ({ message: '登録に失敗しました' }),\n    });\n\n    render(<Register />);\n    \n    fireEvent.change(screen.getByLabelText('ユーザー名'), { target: { value: 'testuser' } });\n    fireEvent.change(screen.getByLabelText('メールアドレス'), { target: { value: 'test@example.com' } });\n    fireEvent.change(screen.getByLabelText('パスワード'), { target: { value: 'password123' } });\n    fireEvent.change(screen.getByLabelText('パスワード確認'), { target: { value: 'password123' } });\n    fireEvent.click(screen.getByRole('button', { name: '登録' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('登録に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  test('ログイン画面リンクが正しく機能すること', () => {\n    const mockPush = jest.fn();\n    (useRouter as jest.Mock).mockReturnValue({\n      push: mockPush,\n    });\n\n    render(<Register />);\n    \n    fireEvent.click(screen.getByText('ログイン画面へ'));\n\n    expect(mockPush).toHaveBeenCalledWith('/login');\n  });\n});"
    },
    {
      "fileName": "login.ts",
      "handleProcedure": "1. クライアントから送信されたログイン情報を受け取る 2. usersテーブルでユーザーを検索 3. パスワードを照合 4. 認証成功時はJWTトークンを生成し返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-001",
      "handleName": "ユーザーログイン",
      "description": "ユーザーの認証とトークン発行",
      "id": "BAC-002",
      "category": "認証",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginPage from '@/app/login/page';\nimport axios from 'axios';\n\njest.mock('axios');\n\ndescribe('LoginPage', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('ログインフォームが正しくレンダリングされること', () => {\n    render(<LoginPage />);\n    \n    expect(screen.getByLabelText('ユーザー名またはメールアドレス')).toBeInTheDocument();\n    expect(screen.getByLabelText('パスワード')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: 'ログイン' })).toBeInTheDocument();\n    expect(screen.getByText('パスワードを忘れた場合')).toBeInTheDocument();\n    expect(screen.getByText('新規登録')).toBeInTheDocument();\n  });\n\n  test('フォームの入力値が正しく更新されること', async () => {\n    render(<LoginPage />);\n    \n    const usernameInput = screen.getByLabelText('ユーザー名またはメールアドレス');\n    const passwordInput = screen.getByLabelText('パスワード');\n\n    await userEvent.type(usernameInput, 'testuser');\n    await userEvent.type(passwordInput, 'password123');\n\n    expect(usernameInput).toHaveValue('testuser');\n    expect(passwordInput).toHaveValue('password123');\n  });\n\n  test('ログイン成功時にホーム画面に遷移すること', async () => {\n    (axios.post as jest.Mock).mockResolvedValue({ data: { token: 'fake-token' } });\n    \n    render(<LoginPage />);\n    \n    await userEvent.type(screen.getByLabelText('ユーザー名またはメールアドレス'), 'testuser');\n    await userEvent.type(screen.getByLabelText('パスワード'), 'password123');\n    await userEvent.click(screen.getByRole('button', { name: 'ログイン' }));\n\n    await waitFor(() => {\n      expect(axios.post).toHaveBeenCalledWith('/api/login', {\n        username: 'testuser',\n        password: 'password123'\n      });\n      expect(global.mockNextRouter.push).toHaveBeenCalledWith('/dashboard');\n    });\n  });\n\n  test('ログイン失敗時にエラーメッセージが表示されること', async () => {\n    (axios.post as jest.Mock).mockRejectedValue(new Error('認証に失敗しました'));\n    \n    render(<LoginPage />);\n    \n    await userEvent.type(screen.getByLabelText('ユーザー名またはメールアドレス'), 'wronguser');\n    await userEvent.type(screen.getByLabelText('パスワード'), 'wrongpassword');\n    await userEvent.click(screen.getByRole('button', { name: 'ログイン' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('認証に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  test('パスワード忘れリンクがクリックされた時に正しいページに遷移すること', async () => {\n    render(<LoginPage />);\n    \n    await userEvent.click(screen.getByText('パスワードを忘れた場合'));\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/forgot-password');\n  });\n\n  test('新規登録リンクがクリックされた時に正しいページに遷移すること', async () => {\n    render(<LoginPage />);\n    \n    await userEvent.click(screen.getByText('新規登録'));\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/register');\n  });\n});"
    },
    {
      "fileName": "create-schedule.ts",
      "handleProcedure": "1. クライアントから送信されたスケジュール情報を受け取る 2. JWTトークンからユーザーIDを取得 3. schedulesテーブルに新規スケジュールを登録 4. 登録成功時は作成されたスケジュール情報を返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-004",
      "handleName": "スケジュール作成",
      "description": "新規スケジュールの登録",
      "id": "BAC-003",
      "category": "予定管理",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport AddSchedule from '@/app/add-schedule/page';\nimport { useRouter } from 'next/navigation';\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('AddSchedule', () => {\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockReturnValue({\n      push: jest.fn(),\n    });\n  });\n\n  test('コンポーネントが正しくレンダリングされること', () => {\n    render(<AddSchedule />);\n    \n    expect(screen.getByLabelText('開始時間')).toBeInTheDocument();\n    expect(screen.getByLabelText('終了時間')).toBeInTheDocument();\n    expect(screen.getByLabelText('暇な時間')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: '保存' })).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: 'キャンセル' })).toBeInTheDocument();\n  });\n\n  test('フォームに入力して保存ボタンをクリックすると、スケジュールが作成されること', async () => {\n    const mockFetch = jest.spyOn(global, 'fetch').mockResolvedValueOnce({\n      ok: true,\n      json: jest.fn().mockResolvedValueOnce({ id: 'new-schedule-id' }),\n    } as any);\n\n    render(<AddSchedule />);\n\n    fireEvent.change(screen.getByLabelText('開始時間'), { target: { value: '2023-07-01T10:00' } });\n    fireEvent.change(screen.getByLabelText('終了時間'), { target: { value: '2023-07-01T12:00' } });\n    fireEvent.click(screen.getByLabelText('暇な時間'));\n    fireEvent.click(screen.getByRole('button', { name: '保存' }));\n\n    await waitFor(() => {\n      expect(mockFetch).toHaveBeenCalledWith('/api/schedules', expect.any(Object));\n    });\n\n    const router = useRouter();\n    expect(router.push).toHaveBeenCalledWith('/');\n  });\n\n  test('キャンセルボタンをクリックすると、ホーム画面に戻ること', () => {\n    render(<AddSchedule />);\n\n    fireEvent.click(screen.getByRole('button', { name: 'キャンセル' }));\n\n    const router = useRouter();\n    expect(router.push).toHaveBeenCalledWith('/');\n  });\n\n  test('フォームの入力が不完全な場合、エラーメッセージが表示されること', async () => {\n    render(<AddSchedule />);\n\n    fireEvent.click(screen.getByRole('button', { name: '保存' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('開始時間と終了時間を入力してください')).toBeInTheDocument();\n    });\n  });\n\n  test('終了時間が開始時間より早い場合、エラーメッセージが表示されること', async () => {\n    render(<AddSchedule />);\n\n    fireEvent.change(screen.getByLabelText('開始時間'), { target: { value: '2023-07-01T12:00' } });\n    fireEvent.change(screen.getByLabelText('終了時間'), { target: { value: '2023-07-01T10:00' } });\n    fireEvent.click(screen.getByRole('button', { name: '保存' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('終了時間は開始時間より後に設定してください')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "update-schedule.ts",
      "handleProcedure": "1. クライアントから送信されたスケジュール更新情報を受け取る 2. JWTトークンからユーザーIDを取得 3. スケジュールの所有者を確認 4. schedulesテーブルの該当スケジュールを更新 5. 更新成功時は更新されたスケジュール情報を返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-005",
      "handleName": "スケジュール更新",
      "description": "既存スケジュールの更新",
      "id": "BAC-004",
      "category": "予定管理",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport EditSchedule from '@/app/[scheduleId]/edit-schedule/page';\nimport { useRouter } from 'next/navigation';\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('EditSchedule コンポーネント', () => {\n  const mockRouter = {\n    push: jest.fn(),\n    back: jest.fn(),\n  };\n\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockReturnValue(mockRouter);\n  });\n\n  it('既存の予定情報が表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({\n        id: '1',\n        startTime: '2023-06-01T10:00:00',\n        endTime: '2023-06-01T12:00:00',\n        isFreeTime: true,\n      }),\n    });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      expect(screen.getByLabelText('開始時間')).toHaveValue('2023-06-01T10:00:00');\n      expect(screen.getByLabelText('終了時間')).toHaveValue('2023-06-01T12:00:00');\n      expect(screen.getByLabelText('暇な時間')).toBeChecked();\n    });\n  });\n\n  it('予定を更新できる', async () => {\n    global.fetch = jest.fn()\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          id: '1',\n          startTime: '2023-06-01T10:00:00',\n          endTime: '2023-06-01T12:00:00',\n          isFreeTime: true,\n        }),\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({ message: '更新成功' }),\n      });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.change(screen.getByLabelText('開始時間'), { target: { value: '2023-06-01T11:00:00' } });\n      fireEvent.change(screen.getByLabelText('終了時間'), { target: { value: '2023-06-01T13:00:00' } });\n      fireEvent.click(screen.getByLabelText('暇な時間'));\n    });\n\n    fireEvent.click(screen.getByText('更新'));\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(mockRouter.push).toHaveBeenCalledWith('/');\n    });\n  });\n\n  it('予定を削除できる', async () => {\n    global.fetch = jest.fn()\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          id: '1',\n          startTime: '2023-06-01T10:00:00',\n          endTime: '2023-06-01T12:00:00',\n          isFreeTime: true,\n        }),\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({ message: '削除成功' }),\n      });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.click(screen.getByText('削除'));\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(mockRouter.push).toHaveBeenCalledWith('/');\n    });\n  });\n\n  it('キャンセルボタンでホーム画面に戻る', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({\n        id: '1',\n        startTime: '2023-06-01T10:00:00',\n        endTime: '2023-06-01T12:00:00',\n        isFreeTime: true,\n      }),\n    });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.click(screen.getByText('キャンセル'));\n    });\n\n    expect(mockRouter.back).toHaveBeenCalled();\n  });\n\n  it('エラー時にエラーメッセージを表示する', async () => {\n    global.fetch = jest.fn().mockRejectedValueOnce(new Error('エラーが発生しました'));\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "delete-schedule.ts",
      "handleProcedure": "1. クライアントから送信されたスケジュールIDを受け取る 2. JWTトークンからユーザーIDを取得 3. スケジュールの所有者を確認 4. schedulesテーブルから該当スケジュールを削除 5. 削除成功時は成功メッセージを返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-005",
      "handleName": "スケジュール削除",
      "description": "既存スケジュールの削除",
      "id": "BAC-005",
      "category": "予定管理",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport EditSchedule from '@/app/[scheduleId]/edit-schedule/page';\nimport { useRouter } from 'next/navigation';\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('EditSchedule コンポーネント', () => {\n  const mockRouter = {\n    push: jest.fn(),\n    back: jest.fn(),\n  };\n\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockReturnValue(mockRouter);\n  });\n\n  it('既存の予定情報が表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({\n        id: '1',\n        startTime: '2023-06-01T10:00:00',\n        endTime: '2023-06-01T12:00:00',\n        isFreeTime: true,\n      }),\n    });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      expect(screen.getByLabelText('開始時間')).toHaveValue('2023-06-01T10:00:00');\n      expect(screen.getByLabelText('終了時間')).toHaveValue('2023-06-01T12:00:00');\n      expect(screen.getByLabelText('暇な時間')).toBeChecked();\n    });\n  });\n\n  it('予定を更新できる', async () => {\n    global.fetch = jest.fn()\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          id: '1',\n          startTime: '2023-06-01T10:00:00',\n          endTime: '2023-06-01T12:00:00',\n          isFreeTime: true,\n        }),\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({ message: '更新成功' }),\n      });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.change(screen.getByLabelText('開始時間'), { target: { value: '2023-06-01T11:00:00' } });\n      fireEvent.change(screen.getByLabelText('終了時間'), { target: { value: '2023-06-01T13:00:00' } });\n      fireEvent.click(screen.getByLabelText('暇な時間'));\n    });\n\n    fireEvent.click(screen.getByText('更新'));\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(mockRouter.push).toHaveBeenCalledWith('/');\n    });\n  });\n\n  it('予定を削除できる', async () => {\n    global.fetch = jest.fn()\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({\n          id: '1',\n          startTime: '2023-06-01T10:00:00',\n          endTime: '2023-06-01T12:00:00',\n          isFreeTime: true,\n        }),\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        json: () => Promise.resolve({ message: '削除成功' }),\n      });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.click(screen.getByText('削除'));\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledTimes(2);\n      expect(mockRouter.push).toHaveBeenCalledWith('/');\n    });\n  });\n\n  it('キャンセルボタンでホーム画面に戻る', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({\n        id: '1',\n        startTime: '2023-06-01T10:00:00',\n        endTime: '2023-06-01T12:00:00',\n        isFreeTime: true,\n      }),\n    });\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      fireEvent.click(screen.getByText('キャンセル'));\n    });\n\n    expect(mockRouter.back).toHaveBeenCalled();\n  });\n\n  it('エラー時にエラーメッセージを表示する', async () => {\n    global.fetch = jest.fn().mockRejectedValueOnce(new Error('エラーが発生しました'));\n\n    render(<EditSchedule params={{ scheduleId: '1' }} />);\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "get-schedules.ts",
      "handleProcedure": "1. JWTトークンからユーザーIDを取得 2. schedulesテーブルから該当ユーザーのスケジュールを取得 3. 取得したスケジュール一覧を返す",
      "relatedScreen": "SCR-003",
      "handleName": "スケジュール取得",
      "description": "ユーザーのスケジュール一覧取得",
      "id": "BAC-006",
      "category": "予定管理",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Home from '@/app/index/page';\nimport { act } from 'react-dom/test-utils';\n\n// モックの設定\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\njest.mock('axios');\n\ndescribe('Home コンポーネント', () => {\n  beforeEach(() => {\n    // Axios モックのリセット\n    jest.clearAllMocks();\n  });\n\n  test('ユーザーの予定リストが表示される', async () => {\n    const mockSchedules = [\n      { id: '1', title: '予定1', start_time: '2023-06-01T10:00:00', end_time: '2023-06-01T11:00:00' },\n      { id: '2', title: '予定2', start_time: '2023-06-02T14:00:00', end_time: '2023-06-02T15:00:00' },\n    ];\n\n    global.axios.get.mockResolvedValue({ data: mockSchedules });\n\n    await act(async () => {\n      render(<Home />);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('予定1')).toBeInTheDocument();\n      expect(screen.getByText('予定2')).toBeInTheDocument();\n    });\n  });\n\n  test('友達の暇な時間タイムラインが表示される', async () => {\n    const mockFriendSchedules = [\n      { id: '3', username: '友達1', start_time: '2023-06-03T13:00:00', end_time: '2023-06-03T14:00:00' },\n      { id: '4', username: '友達2', start_time: '2023-06-04T16:00:00', end_time: '2023-06-04T17:00:00' },\n    ];\n\n    global.axios.get.mockResolvedValue({ data: mockFriendSchedules });\n\n    await act(async () => {\n      render(<Home />);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('友達1')).toBeInTheDocument();\n      expect(screen.getByText('友達2')).toBeInTheDocument();\n    });\n  });\n\n  test('予定追加ボタンをクリックすると予定追加画面に遷移する', async () => {\n    const mockPush = jest.fn();\n    jest.spyOn(require('next/navigation'), 'useRouter').mockImplementation(() => ({\n      push: mockPush,\n    }));\n\n    render(<Home />);\n\n    const addButton = screen.getByText('予定を追加');\n    fireEvent.click(addButton);\n\n    expect(mockPush).toHaveBeenCalledWith('/add-schedule');\n  });\n\n  test('ナビゲーションバーが表示される', () => {\n    render(<Home />);\n\n    expect(screen.getByRole('navigation')).toBeInTheDocument();\n    expect(screen.getByText('ホーム')).toBeInTheDocument();\n    expect(screen.getByText('フレンド')).toBeInTheDocument();\n    expect(screen.getByText('設定')).toBeInTheDocument();\n  });\n\n  test('スケジュールの取得に失敗した場合エラーメッセージが表示される', async () => {\n    global.axios.get.mockRejectedValue(new Error('スケジュールの取得に失敗しました'));\n\n    await act(async () => {\n      render(<Home />);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('スケジュールの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "send-friend-request.ts",
      "handleProcedure": "1. クライアントから送信された友達候補のユーザーIDを受け取る 2. JWTトークンからユーザーIDを取得 3. friendsテーブルに新規リクエストを登録(statusはpending) 4. 登録成功時は成功メッセージを返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-007",
      "handleName": "友達リクエスト送信",
      "description": "新規友達リクエストの送信",
      "id": "BAC-007",
      "category": "友達管理",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport AddFriend from '@/app/add-friend/page';\nimport { act } from 'react-dom/test-utils';\n\n// モックの設定\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\ndescribe('友達追加画面', () => {\n  beforeEach(() => {\n    // フェッチのモックをリセット\n    global.fetch.mockReset();\n  });\n\n  test('ユーザー検索バーが表示される', () => {\n    render(<AddFriend />);\n    expect(screen.getByPlaceholderText('ユーザー名またはメールアドレスを入力')).toBeInTheDocument();\n  });\n\n  test('検索結果が表示される', async () => {\n    global.fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => ([{ id: '1', username: 'テストユーザー' }]),\n    });\n\n    render(<AddFriend />);\n    const searchInput = screen.getByPlaceholderText('ユーザー名またはメールアドレスを入力');\n    fireEvent.change(searchInput, { target: { value: 'テスト' } });\n\n    await waitFor(() => {\n      expect(screen.getByText('テストユーザー')).toBeInTheDocument();\n    });\n  });\n\n  test('友達リクエスト送信ボタンをクリックできる', async () => {\n    global.fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => ([{ id: '1', username: 'テストユーザー' }]),\n    });\n\n    global.fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({ message: '友達リクエストを送信しました' }),\n    });\n\n    render(<AddFriend />);\n    const searchInput = screen.getByPlaceholderText('ユーザー名またはメールアドレスを入力');\n    fireEvent.change(searchInput, { target: { value: 'テスト' } });\n\n    await waitFor(() => {\n      const sendRequestButton = screen.getByText('友達リクエスト送信');\n      fireEvent.click(sendRequestButton);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('友達リクエストを送信しました')).toBeInTheDocument();\n    });\n  });\n\n  test('エラー時にエラーメッセージが表示される', async () => {\n    global.fetch.mockRejectedValueOnce(new Error('ネットワークエラー'));\n\n    render(<AddFriend />);\n    const searchInput = screen.getByPlaceholderText('ユーザー名またはメールアドレスを入力');\n    fireEvent.change(searchInput, { target: { value: 'テスト' } });\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました：ネットワークエラー')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "approve-friend-request.ts",
      "handleProcedure": "1. クライアントから送信された友達リクエストIDを受け取る 2. JWTトークンからユーザーIDを取得 3. friendsテーブルの該当リクエストのstatusをapprovedに更新 4. 更新成功時は成功メッセージを返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-008",
      "handleName": "友達リクエスト承認",
      "description": "受信した友達リクエストの承認",
      "id": "BAC-008",
      "category": "友達管理",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport FriendRequests from '@/app/friend-requests/page';\n\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\nconst mockFriendRequests = [\n  { id: '1', username: 'ユーザー1' },\n  { id: '2', username: 'ユーザー2' },\n];\n\ndescribe('FriendRequests コンポーネント', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn().mockResolvedValue({\n      json: jest.fn().mockResolvedValue({ friendRequests: mockFriendRequests }),\n      ok: true,\n    });\n  });\n\n  test('友達リクエストが正しく表示される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('ユーザー1')).toBeInTheDocument();\n      expect(screen.getByText('ユーザー2')).toBeInTheDocument();\n    });\n  });\n\n  test('承認ボタンをクリックすると、承認リクエストが送信される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      const approveButtons = screen.getAllByText('承認');\n      fireEvent.click(approveButtons[0]);\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith('/api/approve-friend-request', expect.any(Object));\n    });\n  });\n\n  test('拒否ボタンをクリックすると、拒否リクエストが送信される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      const rejectButtons = screen.getAllByText('拒否');\n      fireEvent.click(rejectButtons[0]);\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith('/api/reject-friend-request', expect.any(Object));\n    });\n  });\n\n  test('エラーが発生した場合、エラーメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockRejectedValue(new Error('ネットワークエラー'));\n\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('友達リクエストの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  test('友達リクエストが空の場合、適切なメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValue({\n      json: jest.fn().mockResolvedValue({ friendRequests: [] }),\n      ok: true,\n    });\n\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('友達リクエストはありません')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "reject-friend-request.ts",
      "handleProcedure": "1. クライアントから送信された友達リクエストIDを受け取る 2. JWTトークンからユーザーIDを取得 3. friendsテーブルから該当リクエストを削除 4. 削除成功時は成功メッセージを返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-008",
      "handleName": "友達リクエスト拒否",
      "description": "受信した友達リクエストの拒否",
      "id": "BAC-009",
      "category": "友達管理",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport FriendRequests from '@/app/friend-requests/page';\n\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\nconst mockFriendRequests = [\n  { id: '1', username: 'ユーザー1' },\n  { id: '2', username: 'ユーザー2' },\n];\n\ndescribe('FriendRequests コンポーネント', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn().mockResolvedValue({\n      json: jest.fn().mockResolvedValue({ friendRequests: mockFriendRequests }),\n      ok: true,\n    });\n  });\n\n  test('友達リクエストが正しく表示される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('ユーザー1')).toBeInTheDocument();\n      expect(screen.getByText('ユーザー2')).toBeInTheDocument();\n    });\n  });\n\n  test('承認ボタンをクリックすると、承認リクエストが送信される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      const approveButtons = screen.getAllByText('承認');\n      fireEvent.click(approveButtons[0]);\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith('/api/approve-friend-request', expect.any(Object));\n    });\n  });\n\n  test('拒否ボタンをクリックすると、拒否リクエストが送信される', async () => {\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      const rejectButtons = screen.getAllByText('拒否');\n      fireEvent.click(rejectButtons[0]);\n    });\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith('/api/reject-friend-request', expect.any(Object));\n    });\n  });\n\n  test('エラーが発生した場合、エラーメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockRejectedValue(new Error('ネットワークエラー'));\n\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('友達リクエストの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  test('友達リクエストが空の場合、適切なメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValue({\n      json: jest.fn().mockResolvedValue({ friendRequests: [] }),\n      ok: true,\n    });\n\n    render(<FriendRequests />);\n\n    await waitFor(() => {\n      expect(screen.getByText('友達リクエストはありません')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "get-friends.ts",
      "handleProcedure": "1. JWTトークンからユーザーIDを取得 2. friendsテーブルから該当ユーザーの友達関係を取得(statusがapproved) 3. 取得した友達リストを返す",
      "relatedScreen": "SCR-006",
      "handleName": "友達リスト取得",
      "description": "ユーザーの友達リスト取得",
      "id": "BAC-010",
      "category": "友達管理",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Friends from '@/app/friends/page';\nimport { useState, useEffect } from 'react';\n\n// モックの作成\njest.mock('react', () => ({\n  ...jest.requireActual('react'),\n  useState: jest.fn(),\n  useEffect: jest.fn(),\n}));\n\njest.mock('axios');\n\ndescribe('友達リスト画面', () => {\n  const mockSetFriends = jest.fn();\n  const mockSetSearchTerm = jest.fn();\n  const mockFriends = [\n    { id: '1', username: '友達1' },\n    { id: '2', username: '友達2' },\n  ];\n\n  beforeEach(() => {\n    (useState as jest.Mock).mockImplementation((initialState) => [initialState, mockSetFriends]);\n    (useState as jest.Mock).mockImplementationOnce(() => [mockFriends, mockSetFriends]);\n    (useState as jest.Mock).mockImplementationOnce(() => ['', mockSetSearchTerm]);\n    (useEffect as jest.Mock).mockImplementation((f) => f());\n    \n    global.axios.get.mockResolvedValue({ data: mockFriends });\n  });\n\n  test('友達リストが正しく表示される', async () => {\n    render(<Friends />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('友達1')).toBeInTheDocument();\n      expect(screen.getByText('友達2')).toBeInTheDocument();\n    });\n  });\n\n  test('友達検索バーが機能する', async () => {\n    render(<Friends />);\n    \n    const searchInput = screen.getByPlaceholderText('友達を検索') as HTMLInputElement;\n    fireEvent.change(searchInput, { target: { value: '友達1' } });\n    \n    expect(mockSetSearchTerm).toHaveBeenCalledWith('友達1');\n  });\n\n  test('友達追加ボタンがクリックできる', () => {\n    render(<Friends />);\n    \n    const addButton = screen.getByText('友達を追加');\n    fireEvent.click(addButton);\n    \n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/add-friend');\n  });\n\n  test('友達をクリックすると詳細画面に遷移する', () => {\n    render(<Friends />);\n    \n    const friendItem = screen.getByText('友達1');\n    fireEvent.click(friendItem);\n    \n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/friend/1');\n  });\n\n  test('エラー時にエラーメッセージが表示される', async () => {\n    global.axios.get.mockRejectedValueOnce(new Error('友達リストの取得に失敗しました'));\n    \n    render(<Friends />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('友達リストの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "generate-share-link.ts",
      "handleProcedure": "1. クライアントから送信された有効期限情報を受け取る 2. JWTトークンからユーザーIDを取得 3. ユニークなリンクトークンを生成 4. share_linksテーブルに新規共有リンク情報を登録 5. 生成された共有リンク情報を返す",
      "relatedScreen": "SCR-009",
      "handleName": "共有リンク生成",
      "description": "スケジュール共有用のリンク生成",
      "id": "BAC-011",
      "category": "共有",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport GenerateShareLink from '@/app/generate-share-link/page';\n\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\ndescribe('GenerateShareLink', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({ link: 'https://example.com/share/abc123' }),\n      })\n    );\n  });\n\n  it('有効期限フィールドが正しくレンダリングされる', () => {\n    render(<GenerateShareLink />);\n    expect(screen.getByLabelText('有効期限')).toBeInTheDocument();\n  });\n\n  it('リンク生成ボタンが正しくレンダリングされる', () => {\n    render(<GenerateShareLink />);\n    expect(screen.getByText('リンクを生成')).toBeInTheDocument();\n  });\n\n  it('リンク生成ボタンをクリックするとAPIが呼び出される', async () => {\n    render(<GenerateShareLink />);\n    fireEvent.click(screen.getByText('リンクを生成'));\n    await waitFor(() => expect(global.fetch).toHaveBeenCalledTimes(1));\n  });\n\n  it('APIからのレスポンスが表示される', async () => {\n    render(<GenerateShareLink />);\n    fireEvent.click(screen.getByText('リンクを生成'));\n    await waitFor(() => {\n      expect(screen.getByText('https://example.com/share/abc123')).toBeInTheDocument();\n    });\n  });\n\n  it('コピーボタンが正しく機能する', async () => {\n    Object.assign(navigator, {\n      clipboard: {\n        writeText: jest.fn(),\n      },\n    });\n    render(<GenerateShareLink />);\n    fireEvent.click(screen.getByText('リンクを生成'));\n    await waitFor(() => {\n      expect(screen.getByText('https://example.com/share/abc123')).toBeInTheDocument();\n    });\n    fireEvent.click(screen.getByText('コピー'));\n    expect(navigator.clipboard.writeText).toHaveBeenCalledWith('https://example.com/share/abc123');\n  });\n\n  it('有効期限を設定してリンクを生成できる', async () => {\n    render(<GenerateShareLink />);\n    fireEvent.change(screen.getByLabelText('有効期限'), { target: { value: '2023-12-31' } });\n    fireEvent.click(screen.getByText('リンクを生成'));\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          method: 'POST',\n          body: JSON.stringify({ expirationDate: '2023-12-31' }),\n        })\n      );\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示される', async () => {\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: false,\n        json: () => Promise.resolve({ error: 'エラーが発生しました' }),\n      })\n    );\n    render(<GenerateShareLink />);\n    fireEvent.click(screen.getByText('リンクを生成'));\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "get-shared-schedule.ts",
      "handleProcedure": "1. クライアントから送信された共有リンクトークンを受け取る 2. share_linksテーブルで有効な共有リンクを確認 3. 関連するユーザーのスケジュールをschedulesテーブルから取得 4. 取得したスケジュール情報を返す",
      "relatedScreen": "SCR-010",
      "handleName": "共有スケジュール取得",
      "description": "共有リンクによるスケジュール取得",
      "id": "BAC-012",
      "category": "共有",
      "relatedFrontendCode": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport SharedSchedule from '@/app/[linkToken]/shared-schedule/page';\nimport { useRouter } from 'next/navigation';\n\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n}));\n\ndescribe('SharedSchedule', () => {\n  const mockRouter = {\n    push: jest.fn(),\n    query: { linkToken: 'mockLinkToken' },\n  };\n\n  beforeEach(() => {\n    (useRouter as jest.Mock).mockReturnValue(mockRouter);\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        json: () => Promise.resolve({ schedules: [] }),\n      })\n    ) as jest.Mock;\n  });\n\n  it('共有スケジュール表示画面が正しくレンダリングされること', async () => {\n    render(<SharedSchedule />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('共有スケジュール')).toBeInTheDocument();\n    });\n  });\n\n  it('スケジュールデータが正しく取得され表示されること', async () => {\n    const mockSchedules = [\n      { id: '1', startTime: '2023-06-01T10:00:00', endTime: '2023-06-01T12:00:00', isFreeTime: true },\n    ];\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      json: () => Promise.resolve({ schedules: mockSchedules }),\n    });\n\n    render(<SharedSchedule />);\n\n    await waitFor(() => {\n      expect(screen.getByText('2023年6月1日 10:00 - 12:00')).toBeInTheDocument();\n    });\n  });\n\n  it('エラーが発生した場合にエラーメッセージが表示されること', async () => {\n    (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('ネットワークエラー'));\n\n    render(<SharedSchedule />);\n\n    await waitFor(() => {\n      expect(screen.getByText('スケジュールの取得中にエラーが発生しました。')).toBeInTheDocument();\n    });\n  });\n\n  it('「戻る」ボタンをクリックするとホーム画面に遷移すること', () => {\n    render(<SharedSchedule />);\n\n    const backButton = screen.getByText('戻る');\n    fireEvent.click(backButton);\n\n    expect(mockRouter.push).toHaveBeenCalledWith('/');\n  });\n});"
    },
    {
      "fileName": "update-profile.ts",
      "handleProcedure": "1. クライアントから送信されたプロフィール更新情報を受け取る 2. JWTトークンからユーザーIDを取得 3. usersテーブルの該当ユーザー情報を更新 4. 更新成功時は更新されたユーザー情報を返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-011",
      "handleName": "プロフィール更新",
      "description": "ユーザープロフィールの更新",
      "id": "BAC-013",
      "category": "設定",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport ProfileSettings from '@/app/profile-settings/page';\n\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n  }),\n}));\n\ndescribe('ProfileSettings', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('初期レンダリング時に正しくコンポーネントが表示される', () => {\n    render(<ProfileSettings />);\n    \n    expect(screen.getByLabelText('ユーザー名')).toBeInTheDocument();\n    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument();\n    expect(screen.getByLabelText('新しいパスワード')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: '保存' })).toBeInTheDocument();\n  });\n\n  test('入力フィールドの値が変更できる', () => {\n    render(<ProfileSettings />);\n    \n    const usernameInput = screen.getByLabelText('ユーザー名');\n    const emailInput = screen.getByLabelText('メールアドレス');\n    const passwordInput = screen.getByLabelText('新しいパスワード');\n\n    fireEvent.change(usernameInput, { target: { value: '新しいユーザー名' } });\n    fireEvent.change(emailInput, { target: { value: 'newemail@example.com' } });\n    fireEvent.change(passwordInput, { target: { value: 'newpassword123' } });\n\n    expect(usernameInput).toHaveValue('新しいユーザー名');\n    expect(emailInput).toHaveValue('newemail@example.com');\n    expect(passwordInput).toHaveValue('newpassword123');\n  });\n\n  test('フォーム送信時にAPIが呼び出され、成功メッセージが表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({ message: 'プロフィールが更新されました' }),\n    });\n\n    render(<ProfileSettings />);\n\n    fireEvent.change(screen.getByLabelText('ユーザー名'), { target: { value: '新しいユーザー名' } });\n    fireEvent.change(screen.getByLabelText('メールアドレス'), { target: { value: 'newemail@example.com' } });\n    fireEvent.change(screen.getByLabelText('新しいパスワード'), { target: { value: 'newpassword123' } });\n\n    fireEvent.click(screen.getByRole('button', { name: '保存' }));\n\n    await waitFor(() => {\n      expect(global.fetch).toHaveBeenCalledWith('/api/update-profile', expect.any(Object));\n      expect(screen.getByText('プロフィールが更新されました')).toBeInTheDocument();\n    });\n  });\n\n  test('APIエラー時にエラーメッセージが表示される', async () => {\n    global.fetch = jest.fn().mockResolvedValueOnce({\n      ok: false,\n      json: () => Promise.resolve({ message: 'プロフィールの更新に失敗しました' }),\n    });\n\n    render(<ProfileSettings />);\n\n    fireEvent.click(screen.getByRole('button', { name: '保存' }));\n\n    await waitFor(() => {\n      expect(screen.getByText('プロフィールの更新に失敗しました')).toBeInTheDocument();\n    });\n  });\n});"
    },
    {
      "fileName": "update-notification-settings.ts",
      "handleProcedure": "1. クライアントから送信された通知設定情報を受け取る 2. JWTトークンからユーザーIDを取得 3. usersテーブルの該当ユーザーの通知設定を更新 4. 更新成功時は更新された通知設定情報を返す 失敗時はエラーメッセージを返す",
      "relatedScreen": "SCR-012",
      "handleName": "通知設定更新",
      "description": "ユーザーの通知設定更新",
      "id": "BAC-014",
      "category": "設定",
      "relatedFrontendCode": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport NotificationSettings from '@/app/notification-settings/page';\nimport axios from 'axios';\n\njest.mock('axios');\n\ndescribe('通知設定画面', () => {\n  beforeEach(() => {\n    axios.post.mockResolvedValue({ data: { success: true } });\n  });\n\n  test('コンポーネントが正しくレンダリングされる', () => {\n    render(<NotificationSettings />);\n    expect(screen.getByText('通知設定')).toBeInTheDocument();\n    expect(screen.getByLabelText('メール通知')).toBeInTheDocument();\n    expect(screen.getByLabelText('プッシュ通知')).toBeInTheDocument();\n    expect(screen.getByLabelText('通知頻度')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: '保存' })).toBeInTheDocument();\n  });\n\n  test('スイッチの切り替えが正しく動作する', () => {\n    render(<NotificationSettings />);\n    const emailSwitch = screen.getByLabelText('メール通知');\n    const pushSwitch = screen.getByLabelText('プッシュ通知');\n\n    fireEvent.click(emailSwitch);\n    expect(emailSwitch).toBeChecked();\n\n    fireEvent.click(pushSwitch);\n    expect(pushSwitch).toBeChecked();\n  });\n\n  test('通知頻度の選択が正しく動作する', () => {\n    render(<NotificationSettings />);\n    const frequencySelect = screen.getByLabelText('通知頻度');\n\n    fireEvent.change(frequencySelect, { target: { value: 'daily' } });\n    expect(frequencySelect).toHaveValue('daily');\n  });\n\n  test('保存ボタンクリック時に正しくAPIが呼ばれる', async () => {\n    render(<NotificationSettings />);\n    const saveButton = screen.getByRole('button', { name: '保存' });\n\n    fireEvent.click(saveButton);\n\n    await waitFor(() => {\n      expect(axios.post).toHaveBeenCalledWith('/api/update-notification-settings', expect.any(Object));\n    });\n  });\n\n  test('APIエラー時にエラーメッセージが表示される', async () => {\n    axios.post.mockRejectedValueOnce(new Error('API Error'));\n    render(<NotificationSettings />);\n    const saveButton = screen.getByRole('button', { name: '保存' });\n\n    fireEvent.click(saveButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('設定の保存に失敗しました。')).toBeInTheDocument();\n    });\n  });\n\n  test('設定保存成功時に成功メッセージが表示される', async () => {\n    render(<NotificationSettings />);\n    const saveButton = screen.getByRole('button', { name: '保存' });\n\n    fireEvent.click(saveButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('設定が保存されました。')).toBeInTheDocument();\n    });\n  });\n});"
    }
  ]
}
